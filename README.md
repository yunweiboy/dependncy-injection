依赖倒置原则是面向对象设计中的基本原则之一，它阐述了高层模块和低层模块的依赖关系应该倒置(如下图)，也就是:

- 高层模块不应该依赖低层模块，二者都应该依赖其抽象
- 抽象不应该依赖细节，细节应该依赖抽象
<div align="left"><img alt="img.png" src="image/img.png"/></div>

依赖倒置原则实际上就是对控制反转(Inversion of Control，IoC)这一概念的阐述，而**依赖注入**是实现控制反转的一种机制。所以可以说，依赖倒置原则是设计级的指导思想，它提出了正确的依赖关系；而依赖注入是实现级的具体设计模式，它将组件的依赖关系控制权移到了外部，实现了组件之间的解耦，是对依赖倒置原则的一种实现手段。

依赖注入可以帮助你开发出松耦合的代码，**松耦合使代码更易于维护**。

### 手动注入
我们先建立一个符合DIP原则的例子，其依赖关系如下图：
<div align="left"><img alt="img_1.png" src="image/img_1.png"/></div>

这里有三个“模块”，从高到低分别为Service、BussinessLogic和DatabaseAccess。Service是一个接口，其实现ServiceImpl依赖BussinessLogic接口。Business是BussinessLogic的实现，它还依赖DatabaseAccess接口。Database则是DatabaseAccess接口的实现。

下面是示例的项目结构布局：
<div align="left"><img alt="img_2.png" src="image/img_2.png"/></div>

### google/wire：编译期的依赖注入
wire是由Google Go Cloud开发包团队于2018年下旬开源的Go编译期依赖注入工具，与uber fx、facebook的inject等使用反射在运行时注入不同的是，wire灵感来自Java的Dagger 2，使用的是代码生成技术，而不是反射或服务定位器(service locator)技术。

相较于运行时依赖注入，编译期间注入的最大好处就是生成的**依赖注入和组装的代码是对你可见的**，没有任何背后的“魔法”。这便于在编译期捕捉到注入过程的错误，也便于代码的调试。

此外，wire团队认为编译期注入可以避免依赖膨胀。Wire生成的代码只会导入所需的依赖项，因此，你的二进制文件不会有未使用的导入。运行时依赖项注入在运行时之前无法识别未使用的依赖项。

下面我们就用wire注入来改造一下上面的示例。
```
注：安装wire命令为go install github.com/google/wire/cmd/wire@latest
```
添加新文件 **/Users/user/Desktop/goprojects/dependncy-injection/wire/wire.go**。
```azure
//go:build wireinject
// +build wireinject

package main

// wire.go

import (
    "demo/business"
    "demo/database"
    "demo/service"

    "github.com/google/wire"
)

func InitializeService() service.Service {
    wire.Build(service.NewService,
        wire.Bind(new(service.Service), new(*service.ServiceImpl)),
        business.NewBusiness,
        wire.Bind(new(business.BusinessLogic), new(*business.Business)),
        database.NewDatabase,
        wire.Bind(new(database.DatabaseAccess), new(*database.Database)),
    )
    return nil
}
```
接下来，我们就可以通过wire命令生成代码，完成注入过程：
```azure
$wire
wire: demo: wrote /Users/tonybai/Go/src/github.com/bigwhite/experiments/dependency-injection-examples/wire/demo/wire_gen.go
```
wire工具基于wire.go生成了wire_gen.go文件，在该示例中，wire_gen.go的内容如下：
```azure
// Code generated by Wire. DO NOT EDIT.
  
//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
    "demo/business"
    "demo/database"
    "demo/service"
)

// Injectors from wire.go:

func InitializeService() service.Service {
    databaseDatabase := database.NewDatabase()
    businessBusiness := business.NewBusiness(databaseDatabase)
    serviceImpl := service.NewService(businessBusiness)
    return serviceImpl
}
```
调整一下main函数，主要是去掉手动组装的过程，改为直接调用InitializeService：
```azure
// dependency-injection-examples/wire/demo/main.go

func main() {
    // make dependency injection by code generated by wire
    svc := InitializeService()
    client := NewClient(svc)
    fmt.Println(client.MakeRequest())
}
```
运行一下wire注入这个demo，其结果与手动注入是一致的。